
# CRYPTOGRAPHIC HASH FUNCTION

* 프로트콜이 중앙집중식 제 3자의 개입 없이 정보에 관한 합의를 이루게 한다.
* 합의를 위해 정보를 조작하지 않도록 하기 위해 암호화를 이용한다.
* 해시코드는 역상저항, 2차 역상저항, 충돌 저항등의 요소를 가지고 있다.
* 여기서 역상 저항은 해시 함수의 입력이자 출력에 해당한다.
* 해시 함수에서는 입력 값마다 서로 다른 출력을 가지게 된다. (deterministic)
* 역상 저항 : 어떤 입력 x가 주어지거나 x의 출력 h가 주어지면 입력 x를 결정하는 것이 계산적으로 어려움을 의미
* 2차 역상저항 : 어떤 x가 있을 때 H(x)와 H(x')의 값이 동일하기 때문에 x'를 계산하기 어렵다 (나의 입력만 해당 출력을 생성할 수 있도록 해야 한다)
* 충돌저항 : 같은 해시값을 갖는 두 개의 임의적 입력 x 및 y를 찾는 것이 어려워야 한다 (같은 출력을 생성하는 두개의 입력을 발견하는 것이 어려워야 한다)
* > 현재 해시 함수는 임의적 크기의 정보를 수용할 수 있으며 고정된 길이의 정보 및 출력을 항상 생성함
### avalanche effect
* 입력값에 비추어 출력값을 예측할 수 없어야 한다.
* 입력을 조금만 변경해도 해시 함수의 출력을 결정할 수 없어야 한다
* 특정 입력에 대해 해시 함수 자체를 실행하지 않는 한에서 함수의 출력을 결정할 수 없어야 한다.
* 출력을 예측할 수 없지만 특정 입력이 항상 특정 출력을 가져야 한다.

## SHA-256
* 비트코인에서 사용하는 해시함수, 임의 크기의 정보를 수용하여 항상 256비트로 출력한다.
* 비트코인에서는 제곱 SHA-256을 사용하며 이는 해시들을 작동시킬 때마다 SHA-256을 두 번 작동시킴을 의미함
* 왜 이중 해시를 사용하나요?(*)

## TAMPER-EVIDENT DATABASE(*)
### 블록 헤더
* 모든 유형의 정보, 타음 스탬프, 난이도 등을 포함한다.
* 블록체인의 중추, 블록해시의 모든 정보를 포함하고 있음
### 블록해시
* 이전 블록 해시는 이전 블록의 포인터 역할을 한다.
* 블록해시(블록 ID)는 이러한 모든 정보의 연속이며 SHA-256 해시함수로 작동한다
### 머클 루트
* 거래를 요약하며 임시 값은 작업 증명이 됨
* 거래에 대한 해당 정보를 포함
* 루트는 거래 내용을 요악, 거래는 머클 트리(=해시이진트리)로부터 생성됨

### 머클트리
* 초기 단계에서 2N 거래를 시작함. 2N 이하 거래를 보유한 경우 2N 값을 구할 마지막 거래를 복제함
* 즉, 머클트리 내에서 어떤 거래를 조작하는 경우 상층부까지 증거를 볼 수 있음을 의미
* 사람들이 서로 다른 노드를 가지게 되면(누군가가 조작을 가했을 경우) 다수가 믿는 머클트리(머클루트)가 참이 됨
* 만약 누군가가 머클 루트에 해당 거래가 포함되었다는 것을 입증하고 싶은 경우  모든 거래가 필요하지 않음. 우리는 2N의 거래를 가지고 있으므로 머클 루트에 N개의 정보가 포함되어 있음을 증명하면 됨 (포함 증명)

## 이전 블록 해시
* 블록 헤더는 모두 다른 구성요소로 이루어져 있으며 블록 ID는 이전 블록 해시와 동일하다.
* 그러므로 블록헤더와 이전 블록 해시를 사용하여 이전이나 회신의 블록해더를 가져오는 것이 가능함
* 이는 머클 루트 또는 블록의 다른 부분에 변경 또는 오류가 생기면 변화는 최신 블록 뿐만 아니라 추후의 블록까지 영향을 미침
* 즉, 모든 블록이 이전 블록에 연결된다.
* 이전 블록에서 발생한 변화는 최신 블록에도 반영된다.

## 논스(*)

### 부분 역상 해시 퍼즐
* 비트코인은 부분 역상 해시 퍼즐을 사용한다.
* 여기에서 특정 논스값 혹은 무작위값을 찾아야 하고 동시에 해시의  3개 구성요소가 목표값보다 모두 작아야 한다.(*)
* 일부 출력 형태와 상응하는 출력을 생성하는 역상을 찾아야 한다. (네트워크에서 결정한 목표보다 낮은 값을 가져야 한다.)
* 특정 퍼즐은 비트코인 작업증명 및 기타 가상 화폐 작업증명을 실행하기 위해 사용한다.

### 부분 역상 해시 퍼즐의 조건
1. 계산적으로 어려워야 한다.
2. 매게변수가 존재해야 한다. = 사람들의 문제 해결 여부에 따라 문제 난이도가 조절되어야 한다.
3. 검증이 쉽게 이루어져야 한다.
* 머클 트리에서 대부분 올바른 거래는 채굴자들 스스로 보상을 진행하는 코인기반 거래가 된다.
* 따라서 이들이 변경되며 증가 시킬 수 있는 논스가 있고, 이는 머클루트를 변경시켜 전혀 다른 퍼즐을 생성할 수 있음
* 이후 다시 헤더에서 논스를 통해 작동하여 오버플로우가 될 대 까지 계속 작동하게 됨

## 디지털 서명을 이용하여 익명으로 네트워크에서 활동하기
* 메세지 서명은 되돌리거나 번복할 수 없어야 한다.
* 이들의 개인키가 메세지에 서명한 유일한 개인키라는 것을 인증할 수 있기 때문
* 비트코인은 ECDSA를 사용하여 개인키 및 공공키를 생성함
* ECDSA는 이산 로그 문제를 제기할 수 있는 유할 아벨군을 정의함(*)
* 2D공간에 타원 곡선을 그릴 수 있고, 범위 내 필요로하는 모든 값이 있는 경계를 정의함 = 특정 길이의 키를 정의하기 위함

## 함수
* 타원 곡선을 이용하는 트랩도어 함수는 연산기능 및 개인키에서 쉽게 구헐 수 있다.
* 작동원리는 코드 탄젠트 프로세스임
* PRIVATE KEY = M (P*Q*R)
* PUBLIC KEY = P^M
* ADDRESS = RIPEMD160(SHA256(PUBLIC KEY))

## PUBKEY HASH

* 보안을 위해서 공공키가 공공키 해시로 변경될 때 이중해시 함수를 사용한다. (using a double hash function), 이를 통해 퀀텀리지스트 함수를 만듬
* 퀀텀리지스트 : 양자 컴퓨터와 같은 빠른 컴퓨터로 억지로 풀려고 해도 복호화 할 수 없음
* Base58Check encode를 통해 사람에게 친숙한 것으로 바뀜
* checksum : 4 byte의 에러 체크 코드(주소 유효성 여부 판단). 생성된 주소의 끝에 붙는다.

## 비트코인 스크립트
* 비트코인으 UTXO 모델을 사용하므로 각각의 거래는 입력값고 출력값이 매칭된다.
* 거래가 안에 잇지만 모든 거래 및 블록이 같은 것은 아님
* 비트코인의 모든 입력과 출력은 스크립트에 해당한다
* LOCKING SCRIPT : 이전 거래의 출력사항. 비트코인의 총량을 결정하고 스크립트 잠금 해제를 진행할 수 있는 모두에게 이를 할당(*)
* 잠금 해재 스크립트 : 해당 거래에서 비트코인을 사용할 때 제공. 비트코인 청산 시 스크립트 또는 해제 스크립트를 제공해야 함
* 비트코인 검증 노드는 네트워크에 존재. 해당 거래 작동 여부를 검증함

### 스크립트 내용의 운영
* 데이터 스텍에서, 스택에 내용을 넣음.
* 해당 스크립트를 실행하는 동안 서명을 얻어야 함<SIG>
* 그 다음 PUBLIC KEY를 스택에 넣음, 출력으 청산하는 사람으로부터 제공받음
* 그 다음 LOCKING SCRIPT로 이동함, 그러면 스택 상단 항목을 복사하고 두 개의 공공키를 보유하게 됨(*), duplicate.
* 이후 상단 해시 > 공개키 해시(unlocking script)를 가짐, 거래를 보내는 사람이 구체화 함
* 같은 공개키 해시인 것을 확인
* 해당 서명이 공개키 해시를 소유한 사람의 실제 서명인지 확인함
* 출력에서 proof of burn(**)을 사용 : 거래를 진행하는 동안 소유한 입력을 확인할 수 있으며 출력에서 원하는 것을 작성할 수 있음

## P2PKH & P2SH (*)
*  P2PKH  : 누군가에게 거래를 보낸 사람이 키의 해시값을 지불하고 있다고 명시(받는사람이 낸다는 소린가..?)
* 청산하는 사람이 해당 비트코인 청산을 위해 공개키를 제공해야 함
*   P2SH : 트랜젝션을 보내는 사람이 스크립트 해시를 명시
* 보다 복잡한 정보 및 데이터가 주소 및 비트코인 청산을 위해 요구됨
* 지불하는 사람은 복잡한 스크립트를 작성할 필요가 없으며 고객은 스크립트를 걱정하지 않아도 됨
*  WHAT IS MULTISIG?(*) : N명의 M에게 거래를 진행하는 방식
* 만약 3명 중 2명의 허가만 있으면 변경 가능하게 할 경우, 스크립트의 승인은 3명 중 두명만 하면 됨.
