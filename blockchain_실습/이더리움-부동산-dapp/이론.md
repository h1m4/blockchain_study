# 이더리움 부동산 Dapp 개발

* 강좌 길이가 길어서 나중에 시작하려고 했으나 다른 강좌가 진행이 안 될 것 같아 먼저 시작함

### 2019-01-12
* geth, truffle, node.js 설치(환경설정)

### 2019-01-14
* 메타마스크 부터
* 제네시스 블록의 초기화\
* 계정생성
* 채굴 및 거래
```
{
  "config": { //체인의 파라미터들을 정의
    "chainId": 4386, //field
    "homesteadBlock": 1,
    "eip150Block": 2,
    "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "eip155Block": 3,
    "eip158Block": 3,
    "byzantiumBlock": 4,
    "ethash": {} //이 체인의 합의 알고리즘이 작업증명임을 말함
  },
  "nonce": "0x0",
  "timestamp": "0x5c3c1f86", // 블록 생성 난이도
  "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x47b760", // 블록 내 트랜젝션이 소비할 수 있는 최대 값
  "difficulty": "0x80000", // 블록 유효성 검사 난이도
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": { //지갑 지급을 미리 보여줌
    "0000000000000000000000000000000000000000": {
      "balance": "0x1"
    },
  "number": "0x0", //블록 넘버, 제네시스이므로 0
  "gasUsed": "0x0", //이 블록에서 트랜젝션등을 처리하면서 사용한 가스의 총량
  "parentHash": //이것의 부모블록 해시 정보를 담음 "0x0000000000000000000000000000000000000000000000000000000000000000"
}
  ```

  * 마이닝 시작하기 전에 가나슈 켜져 있으면 error 발생시킴
  * 3만 블록이 생성될 때 마다 DAG가 생성
  * EPOCH = 3만 블록
  * 내 컴퓨터 내에서는 DAG 파일 생성 굉장히 오래걸림

## 접근제어자
  * external : 외부 컨트렉트에서만 호출 가능, 상태변수는 external 사용 불가
  * internal : 컨트랙트 내부 호출 가능, 상속받은 컨트랙트 호출 가능, 상태변수는 디폴트로 internal
  * 컨트랙트 내부 호출 가능, 상속받은 컨트랙트도 호출 가능, 외부 컨트랙트도 호출 가능
  * private: 컨트랙트 내부만 호출 가능

## 함수 타입 접근제어자
  * view: 데이터 read-only, 가스 비용 없음
  * pure : 데이터 읽지 않음, 인자값만 활용하여 반환 값 정함, 가스비용 없음
  * constant : 이제 안쓰나..? view/pure 대신 쓰였음
  * payable : 함수가 eth 를 받을 수 있게 함, 가스 비용 있음

## 값 타입
  * boolean
  * int : 양수 음수 다 씀
  * uint : 양수만 받음, 저장할 수 있는 수가 int보다 크다
  * address : 두 개의 멤버를 소유, 20byte의 이더리움 계정 주소를 가짐
  * bytes : 고정된 크기의 바이트 배열, byte == bytes1, 문자를 헥스로 변환해서 저장해야함
  * 동적 크기의 bytes 배열 (bytes/string) : 무한, 값타입 x
  * enum : 열거형, 사용자 정의를 만듬. 값을 정수형으로 리턴

## 참조타입
  * storage : 변수를 블록에 영구적으로 저장, 디폴트 상태 변수는 storage
  * memory : 임시 저장 변수, 디폴트로 매개변수와 리턴값은 memory
* 로컬 변수로 쓰일 때 memory

## 정적 배열과 동적 배열
* 정적 배열 : 사이즈가 고정 `uint[5] fixedArray`
    * 함수안에서 리터럴을 통해서 배열을 초기화 할 때 저장위치 memory 써줘야함
* 동적 배열 : 사이즈가 무한대 `uint[] dynamicArray`

## 구조체
 * sturct : 필요한 자료형을 가지고 새롭게 정의하는데 쓰임

 ```
 contract MyContract {
   struct Student {
     string studentName;
     string gender;
     uint age
   }

   Student[] student;

   function addStudent(string _name, string _gender, uint _age) public {
     Student.push(Student(string _name, string _gender, uint _age)); // student 상태변수 배열에 새로운 Student 입력

     Student storage updateStudent = students[0]; // storage에 저장하는 새로운 Student 선언
     // 상태변수 students 배열의 첫번째 인덱스 값을 대입 storage로 선언되었기 때문에 상태변수를 가르키는 포인터 역할을 함

     updateStudent.age = 55; //updateStudent의 age를 55로 변경
     // 즉, 상태변수의 첫번째 인덱스의 age 필드를 55로 변경

     Student meory updateStudent2 = students[0];
     // memory에 저장하는 새로운 Student 선언
     // 상태변수 students 배열의 첫번째 인덱스 값을 대입, momory로 선언했기 때문에 복사한다.


     updateStudent2.age = 20; // updateStudent2의 age 필드를 20으로 변경

     students[0] = updateStudent2 // memory 배열의 값을 상태변수에 직접적으로 대입해주면 students 값 영구히 변경
   }
 }

 ```


## mapping
* `mapping(_KeyType => _ValueType)`
* key와 value를 쌍으로 저장하는 자바의 map과 비슷
* KeyType : 동적 배열, 열거형, 구조체, 매핑 타입 제외 다른 타입들 다 가능
* ValueType : 매핑 포함 다른 타입 다 가능


```
contract MyContract{
  mapping(address -> uint256) balance;
// 어떤 이더리움 주소의 양수값이 블록체인 내에 존재함

  function learnMApping() public {
    balance[msg.sender] = 100; //key = msg.sender : 계정주소를 뜻함. balance의 key값은 주소값임
    balance[msg.sender] += 100;

    uint256 currentBalance = balance[msg.sender];

    uint256 currentBalance = balance[msg.sender];
  }
}
```
